# The container pattern
Полягає в тому щоб розділяти компоненти на дві частини:
* `Container Components` - ті що відповідають за логіку, взаємодію з стором, отримують дані
* `Presentational Components` - ті що фокусуються на UI
Але можна замість такого підходу також просто винести хуки в окремий файл.

# Immutable Data
Зміна стейту в редаксі
`createReducer` в редаксі вже має в собі вбудовану бібілотеку Immer що дозволяє проапдейтити стейт

# HOC
Дозволяє додати якусь логіку до компоненти, як наприклад завантажити дані, а поки вони не завантажились показувати Loading... 
Така компонента обгортаєсять у HOC wrapper, який має в собі потрібну функціональність, наприклад withRouter у react-router

# Compound Component Pattern

# Hooks
## `useRef(initialRefValue)`
дозволяє використати значення ref. Це таке значення яке, на відміну від стейту можна редагувати напряму і воно не впливає на рендерінг. Міняти значення ref можна через його пропертю current.
Часто `ref` використовується щоб зберігати timeoutID або DOM елемент.  
Для того щоб доступитись до DOM елементу через ref треба задати йому атрибут `ref`.  
А якщо потрібно звернутись до DOM елеметну в кастомній компоненті то це потрібно явно прописати в цій компоненті, для цього використати функцію `forwardRef`.
``` jsx
const ExampleComponent = forwardRef((props, ref) => {
    return <div ref={ref}/>
})

export function Block() {
    const innerExample = useRef(null);
    return (
        <div>
            <ExampleComponent ref={innerExample} />
        </div>
    )
}
```
## `useEffect(function, [dependencies])`
dependencies це масив в який можна додати значення стейту чи пропсів.
Якщо не передати dependencies `useEffect` раниться кожного разу після того як компонента відрендерилась і приатачилась в DOM.
Якщо передати dependencies як `[]` то useEffect зараниться лише один раз, при initial render
Якщо передати в dependencies значення, то useEffect зараниться після рендеру, але тільки якщо значення в dependencies змінились.
## `useState(initialStateValue)`
Використовується щоб додати змінну стейту. Вертає два значення: змінну стейту і функцію щоб змінити значення цієї змінної і відповідно запустити ререндер
## `useMemo(function, [dependencies])`
useMemo дозволяє зберегти значення яке верне функція і перезапускати її тільки якщо значення dependencies зміниться
Це дозволяє пофіксити проблему з перформансом в різних кейсах.  
Найпоширеніший це коли ми не хочемо щоб чайлд компонента перерендерилась якщо її пропси не змінились. Тоді пропси які їй передаються беруться з `useMemo`, а також сама компонента огортається в `memo`.
## `useCallback(callbackFunction, [dependencies])`
працює схоже як useMemo але вертає збережену функцію замість значення.  
Дозволяє передати чайлд компоненті функцію якщо ми хочема в чайлд компоненті заюзати `memo`.  
Також якщо нам треба викликати якусь функцію в `useEffect` і ми її передаємо у залежностях, то це дозволяє useEffect не ранитись при кожному рендері.
## `useReducer(reducerFunction, initialState)`
дозволяє засетати стейт не прямо в компоненті, а заюзати для цього функцію редюсер. З цієї функції ми отримуємо два значення `state` і `dispatch`.
Якщо треба змінити стейт то викликаємо dispatch, і тоді власне викликається редюсер функція яку ми передали. 
Вона і відповідає за те щоб змінити стейт. Зазвичай їй передається тип екшину і власне зміни до стейту.
## `useContext()`
дозволяє прокинути дані до іншої компоненти не використовуючи пропсів.