# З чого складається Node.js
![alt text](./images/nodejsComponents.png)


`libuv` - C++ бібілотека що реалізує event loop, але крім цього має й інші фічі для взаємодії з операційною системою.  
`V8` - движок JavaScript, що використовується в Chrome, розроблений Google.  
`C/C++ bindings`  
`http-parser` (до 13 версії), `llhttp` (з 13 версії) - парсери HTTP  
`c-ares` - відповідає за DNS разом з libuv  
`OpenSSL` - crypto  
`zlib`  

## libuv
У дуже ранній версії node використовувала libev, але в 2011 році перейшла на libuv щоб додати підтримку Windows.
![alt text](./images/libuv.png)
Libuv крім event loop має також і інші фічі:
- UDP/TCP сокети
- DNS
- File system
- Thread pool
- Child processes  
- ...

### Event loop
В ноді за event loop відповідає libuv.   
Модель роботи:
* Node.js використовує єдиний основний потік для виконання JavaScript-коду.
* Всі асинхронні операції (файловий ввід/вивід, мережеві запити, таймери) виконуються у фонових потоках (забезпечених libuv) і повертаються до основного потоку через колбеки.

В event loop є різні фази на яких виконуються певні операції:
- timers. Тут виконуються колбеки які були засетані через `setTimeout` і `setInterval`.
- pending callbacks. Тут виконуються колбеки які були deferred на polling фазі.
Наприклад деякі TCP помилки.
- idle, prepare. Виконуються внутрішні операції.
- poll. In this phase, the event loop watches out for new async I/O callbacks.
На цій фазі node перевіряє чи є якісь нові async I/O колбеки для виконання, якщо є то колбеки то їх виконує.
Це майже всі колбки, крім setTimeout, setInterval, setImmediate and closing callbacks.
Якщо немає колбеків то залишається на цій фазі і чекає на них поки <-- це перевірити
- якщо є засетані якісь функції в setImmediate то івент луп переходить на check фазу
- якщо є заекспайрені таймери то переходить на наступну фазу
- check. Тут виконуються колбеки які були засетані через `setImmediate`.
- close callbacks. Тут виконуються колбеки типу socket.on('close', fn) чи process.exit()
Мікротаски це `process.nextTick` і `Promise` і вони виконуються на тій фазі на якій були засетані.


## Скільки потоків у пулі потоків Node.js?

У Node.js за замовчуванням доступно **4 потоки** у пулі потоків (`thread pool`), які забезпечує **libuv** для виконання асинхронних операцій, таких як файловий ввід/вивід, обчислювальні задачі, операції з мережею, що потребують фонової роботи (наприклад, DNS-запити без кешу).

---

### Деталі про пул потоків

#### 1. **Кількість потоків**
- За замовчуванням у `libuv` використовуються **4 потоки**.
- Ця кількість може бути змінена за допомогою змінної середовища `UV_THREADPOOL_SIZE`.
- Максимально можливо встановити до **1024 потоків** (хоча це рідко потрібно).

```bash
UV_THREADPOOL_SIZE=8 node app.js
```

### 2. Що виконується у пулі потоків?

- **Файлові операції**: Наприклад, `fs.readFile`, `fs.writeFile`.
- **Криптографічні обчислення**: Наприклад, `crypto.pbkdf2`, `crypto.randomBytes`.
- **Стиснення**: Наприклад, `zlib`.
- **DNS-запити**: Тільки ті, які використовують функцію `resolve` (без кешу).

### 3. Балансування навантаження

- Якщо всі 4 потоки зайняті, завдання ставляться в чергу.
- Node.js витягує завдання з черги в міру звільнення потоків.




# Глобальні об'єкти
### Cluster
Кластер дає можливість створювати кілька процесів Node і використовувати доступні ядра процесора.

### Event emitter
### Stream
### Buffer
Обʼєкт для роботи з даними що мають фіксований розмір, що дозволяє працювати з бінарними даними, наприклад файлами чи TCP стрімом.
Buffer є сабкласом джаваскріптовог `Uint8Array`, який може мати елементи зі значенням лише від 0 до 255, тобто один байт.

## Garbage collection
Будь яка програма потребує алокації і звільнення памяті. В частині мов, як от в С, це робиться вручну за допомогою операцій `malloc` і `free`. А у JavaScript, це робиться автоматично за допомогою garbage collector.
Коли запускається GC програма зупиняє виконання, офіційна дока Node:
> There's a lot to learn about how the garbage collector works, but if you learn one thing it's that when GC is running, your code is not.
Є два основні алгоритми за якими працює GC:
- Scavenge. Алгоритм для швидкого очищення 'new space'. 
- Mark-and-sweep. Більш повільний алгоритм для очищення 'old space'.
Як оптимізувати використання памяті:
- використовувати стріми
- уникати замикань
- уникати глобальних змінних



