## Розділ 2. Моделі даних
Раніше, ще до реляційних баз даних були такі варіанти як network model і hierarchical model. Ними завідувала організація CODASYL, що займалась стандарнами обробки даних (наприклад вона ще розробила мову COBOL). Вони були незручні, виглядає що через свою імперативність, наприклад щоб доступитись до яогось елементу в network model треба було прописувати цілий ланцюжок шляху до нього. Виходив досить складний query щоб доступитись до якихось даних.
Тоді зявилась альтерантива - реляційна модель. Коли дані представлені не як ієрархічне дерево, а як таблиці що пов'язані між собою за допомогою foreign key. Виявилось що така модель підходить добре для дуже багатьох варіантів і в результаті за якийсь час вона витіснила CODASYL моделі.
Важлива перевага яка була у реляційної моделі, а точніше в SQL це його декларативність.

#### Декларативний vs імперативний стиль
Декларативна мова не вимагає чіткої послідовності інструкцій, а швидше опис результату.
Гарний приклад декларативного стилю це CSS селектори. Наприклад якщо ми хочемо позначити сірим всі елементи що задісейблені:
``` css
*:disabled {
  background-color: dimgrey;
}
```
Якщо ж ми захочемо те саме зробити в js то треба буде вказати це більш конкретно:
```javascript
const disabledElements = document.querySelectorAll(':disabled');
disabledElements.forEach(element => {
    element.style.backgroundColor = 'dimgrey';
});
```
Тобто в css ми не вказуємо конкретно що треба знайти всі елементи що мають псевдоклас `disabled`, пройтись циклом і щось з ними зробити. Браузер вирішує сам якою послідосністю досягти цього.


Також зявились ще й інші варіанти моделей які покривають потреби в яких реляційна модель не найзручніший підхід. Найбільш поширені це Document і Graph model.

### Document model
Чим відрізняються від реліяційної моделі
 - Schema flexibility. У документ базах даних схема може бути відсутня при операції write. Такий підхід буде зручний коли
     * є багато різних типів об'єктів і не дуже практично для кожного створювати табличку
     * структура даних не відома наперед, наприклад залежить від third party систем
 - Простіший код (у певних кейсах). Одна річ через яку любителі ООП критикували SQL бази це те що в них не виходить промапити об'єкт до ентіті в базі даних. Тобто наприклад у нас є обʼєкт Employee і дані про нього розкидані по різних табличках (наприклад таблички Departaments, Projects, Inventory). Нам потрібно писати додатковий код якщо хочемо дістати всі дані про конкретного працівника. І в деяких випадках нам це не потрібно і ми хочемо мати self-contained документ який би одразу містив всі дані про працівника.
 - Data locality. Оскільки весь документ зберігається цілком в одному місці, то і перформанс кращий коли нам треба витягнути цілий документ чи велику його частину. Але гірший якщо потрібна маленька частина або при write операції, бо всеодно треба зчитувати/перезаписувати цілий документ.

 *Note: Є також інші важливі відмінності між реляційними і документ базами даних, окрім моделі даних.*

 #### Map Reduce
 Підхід до обробки даних, коли спочатку відбувається Map процедура - фільтрування, сортування і потім Reduce процедура яка зводить докупи всі проміжні значення пов'язані з одним і тим же проміжним ключем.
 
 В `MongoDB` є функція `mapReduce` яка приймає дві функції  
 `map`, яка запускає `emit(key, values)`  
 `reduce`, яка отримує в аргументах те що запускається в emit але згруповане по values
```javascript
db.collection.mapReduce(
    function() {
        emit(this.category, 1);
    },
    function(key, values) {
        return Array.sum(values);
    },
    {
        out: "map_reduce_example"
    }
)
```
Проте зараз замість mapReduce є більш декларативний `aggeregation`.

### Graph model
Хороший вибір коли зв'язки між даними сильно виражені, все повязано зі всім (наприклад соціальні мережі).
Граф складається з об'єктів двох типів: `vertices` i `edges`.

Два найпоширеніші варіанти graph моделей:
- Progerty graph model.
- Triple stores. Object, predicate, subject.

#### Progerty graph model
У такого типу в нас є `vertice` що власне містить в собі дані (як key value pairs) і списох вхідних і вихідних edges.  
А також є `edge` що має інформацію з якого vertice він починається і яким закінчується, а також лейбл і key-value проперті.  
Ось приклад такої бази і запиту до неї на `Cypher`:
```cypher
CREATE (m:Movie {title: 'The Matrix'})
CREATE (p:Person {name: 'Lana Wachowski'})
CREATE (p)-[:DIRECTED]->(m)

MATCH (m:Movie {title: 'The Matrix'})<-[d:DIRECTED]-(p:Person)
RETURN p.name as director
```

#### Triple stores
Мови Turtle, SPARQL, Datalog  
Ідея та сама що й у property graph, але дані представляються трохи по іншому: як subject, predicate, object.  
`subject` це в цьому випадку `vertex`  
`object` це або vertex або літерал  
Якщо `object` це vertex то predicate це edge, якщо `object` це літерал то таке поєднання subject, predicate, object це аналог key value пари.  
RDF - модель даних для представлення веб даних, походить з ідеї Semantic WEB. І якраз використовує triple store.
Тому в Turtle кожен елемент - subject, predicate, object має бути заданий як URL.

`Datalog` - теж мова для triple store, не така популярна, але якраз в ній закладено базис для інших мов, оскільки вона зявилась найпереше.
В ній дані записуються у форматі `predicate(subject, object)`.
```Datalog
name(namerica, 'North America').
type(namerica, continent).
```

*Тут може зявитись підозра що graph моделі повторюють CODASYL нетворк модель. Прото ні, не повторюють. Основна різниця знову ж в імперативному стилі CODSYL vs декларативному стилі мов для Graph баз даних.*

## Декілька цитат
> For highly interconnected data, the document model is awkward, the relational model is acceptable, and graph models are the motst natural.

> The advantage of using an ID is that because it ha no meaning to humans, it never needs to change.
